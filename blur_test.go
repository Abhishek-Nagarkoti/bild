package bild

import (
	"image"
	"testing"
)

func TestBoxBlur(t *testing.T) {
	cases := []struct {
		radius   float64
		value    image.Image
		expected *image.RGBA
	}{
		{
			radius: 0.0,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
				},
			},
			expected: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
				},
			},
		},
		{
			radius: 1.0,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
				},
			},
			expected: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0x71, 0x71, 0x71, 0xff, 0x71, 0x71, 0x71, 0xff, 0x71, 0x71, 0x71, 0xff,
					0x71, 0x71, 0x71, 0xff, 0x71, 0x71, 0x71, 0xff, 0x71, 0x71, 0x71, 0xff,
					0x71, 0x71, 0x71, 0xff, 0x71, 0x71, 0x71, 0xff, 0x71, 0x71, 0x71, 0xff,
				},
			},
		},
		{
			radius: 1.0,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
				},
			},
			expected: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0x1c, 0x00, 0x00, 0xff, 0x1c, 0x00, 0x00, 0xff, 0x1c, 0x00, 0x00, 0xff,
					0x1c, 0x00, 0x00, 0xff, 0x1c, 0x00, 0x00, 0xff, 0x1c, 0x00, 0x00, 0xff,
					0x1c, 0x00, 0x00, 0xff, 0x1c, 0x00, 0x00, 0xff, 0x1c, 0x00, 0x00, 0xff,
				},
			},
		},
	}

	for _, c := range cases {
		actual := BoxBlur(c.value, c.radius)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("BoxBlur", c.expected, actual))
		}
	}
}

func TestGaussianBlur(t *testing.T) {
	cases := []struct {
		radius   float64
		value    image.Image
		expected *image.RGBA
	}{
		{
			radius: 0.0,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
				},
			},
			expected: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
				},
			},
		},
		{
			radius: 1.0,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x80, 0x80, 0xFF,
				},
			},
			expected: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0x7b, 0x7b, 0x7b, 0xff, 0x7b, 0x7b, 0x7b, 0xff, 0x82, 0x82, 0x82, 0xff,
					0x68, 0x68, 0x68, 0xff, 0x68, 0x68, 0x68, 0xff, 0x70, 0x70, 0x70, 0xff,
					0x68, 0x68, 0x68, 0xff, 0x68, 0x68, 0x68, 0xff, 0x70, 0x70, 0x70, 0xff,
				},
			},
		},
		{
			radius: 1.0,
			value: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
					0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
				},
			},
			expected: &image.RGBA{
				Rect:   image.Rect(0, 0, 3, 3),
				Stride: 3 * 4,
				Pix: []uint8{
					0x17, 0x00, 0x00, 0xff, 0x1e, 0x00, 0x00, 0xff, 0x17, 0x00, 0x00, 0xff,
					0x1e, 0x00, 0x00, 0xff, 0x26, 0x00, 0x00, 0xff, 0x1e, 0x00, 0x00, 0xff,
					0x17, 0x00, 0x00, 0xff, 0x1e, 0x00, 0x00, 0xff, 0x17, 0x00, 0x00, 0xff,
				},
			},
		},
	}

	for _, c := range cases {
		actual := GaussianBlur(c.value, c.radius)
		if !rgbaImageEqual(actual, c.expected) {
			t.Error(testFailMessage("GaussianBlur", c.expected, actual))
		}
	}
}
